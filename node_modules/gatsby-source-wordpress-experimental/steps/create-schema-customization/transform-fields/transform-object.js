"use strict";

exports.__esModule = true;
exports.transformGatsbyNodeObject = exports.transformListOfGatsbyNodes = void 0;

var _helpers = require("../helpers");

var _update = require("../../source-nodes/update-nodes/wp-actions/update");

var _helpers2 = require("../../source-nodes/helpers");

var _getGatsbyApi = require("../../../utils/get-gatsby-api");

const transformListOfGatsbyNodes = ({
  field,
  fieldName
}) => {
  const typeName = (0, _helpers.buildTypeName)(field.type.ofType.name);
  return {
    type: `[${typeName}]`,
    resolve: (source, _, context) => {
      let nodes = null;
      const field = source[fieldName];

      if (field && Array.isArray(field)) {
        nodes = field; // @todo determine if this else if is necessary
        // I think it isn't. The test for this in field-transformers.js line 48
        // is checking if this is a list of Gatsby nodes which means it should be
        // an array, not an object type with nodes as a field.
        // leaving this for now as I have no automated tests yet :scream:
      } else if (source && source.nodes && source.nodes.length) {
        nodes = source.nodes;
      }

      if (!nodes) {
        return null;
      }

      return context.nodeModel.getNodesByIds({
        ids: nodes.map(node => node.id),
        type: typeName
      });
    }
  };
};

exports.transformListOfGatsbyNodes = transformListOfGatsbyNodes;

const transformGatsbyNodeObject = ({
  field,
  fieldName
}) => {
  const typeName = (0, _helpers.buildTypeName)(field.type.name);
  return {
    type: typeName,
    resolve: async (source, _, context) => {
      const nodeField = source[fieldName];

      if (!nodeField || nodeField && !nodeField.id) {
        return null;
      }

      const existingNode = context.nodeModel.getNodeById({
        id: nodeField.id,
        type: typeName
      });

      if (existingNode) {
        return existingNode;
      }

      const queryInfo = (0, _helpers2.getQueryInfoByTypeName)(field.type.name); // if this node doesn't exist, fetch it and create a node

      const {
        node
      } = await (0, _update.fetchAndCreateSingleNode)({
        id: nodeField.id,
        actionType: `CREATE`,
        singleName: queryInfo.typeInfo.singularName
      });

      if (source.id && node) {
        const {
          helpers
        } = (0, _getGatsbyApi.getGatsbyApi)();
        await helpers.actions.createParentChildLink({
          parent: source,
          child: node
        });
      }

      return node || null;
    }
  };
};

exports.transformGatsbyNodeObject = transformGatsbyNodeObject;