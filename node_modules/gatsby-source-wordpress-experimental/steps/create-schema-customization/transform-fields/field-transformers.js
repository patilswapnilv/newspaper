"use strict";

exports.__esModule = true;
exports.fieldTransformers = void 0;

var _helpers = require("../helpers");

var _transformUnion = require("./transform-union");

var _transformObject = require("./transform-object");

var _fetchNodes = require("../../source-nodes/fetch-nodes/fetch-nodes");

const fieldTransformers = [{
  // non null scalars
  test: field => field.type.kind === `NON_NULL` && field.type.ofType.kind === `SCALAR`,
  transform: ({
    field
  }) => {
    if ((0, _helpers.typeIsABuiltInScalar)(field.type)) {
      return `${field.type.ofType.name}!`;
    } else {
      return `JSON!`;
    }
  }
}, {
  // non null lists
  test: field => {
    var _field$type$ofType, _field$type$ofType$of;

    return field.type.kind === `NON_NULL` && field.type.ofType.kind === `LIST` && (field.type.ofType.name || ((_field$type$ofType = field.type.ofType) === null || _field$type$ofType === void 0 ? void 0 : (_field$type$ofType$of = _field$type$ofType.ofType) === null || _field$type$ofType$of === void 0 ? void 0 : _field$type$ofType$of.name));
  },
  transform: ({
    field
  }) => {
    const typeName = (0, _helpers.findTypeName)(field.type);
    const normalizedTypeName = (0, _helpers.typeIsABuiltInScalar)(field.type) ? typeName : (0, _helpers.buildTypeName)(typeName);
    return `[${normalizedTypeName}]!`;
  }
}, {
  // non null lists of non null types
  test: field => {
    var _field$type$ofType2, _field$type$ofType2$o;

    return field.type.kind === `NON_NULL` && field.type.ofType.kind === `LIST` && ((_field$type$ofType2 = field.type.ofType) === null || _field$type$ofType2 === void 0 ? void 0 : (_field$type$ofType2$o = _field$type$ofType2.ofType) === null || _field$type$ofType2$o === void 0 ? void 0 : _field$type$ofType2$o.kind) === `NON_NULL`;
  },
  transform: ({
    field,
    fieldName
  }) => {
    const originalTypeName = (0, _helpers.findTypeName)(field.type);
    const typeKind = (0, _helpers.findTypeKind)(field.type);
    const normalizedType = typeKind === `SCALAR` && (0, _helpers.typeIsABuiltInScalar)(field.type) ? originalTypeName : (0, _helpers.buildTypeName)(originalTypeName);
    return {
      type: `[${normalizedType}!]!`,
      resolve: source => {
        var _field$type;

        const resolvedField = source[fieldName];

        if (typeof resolvedField !== `undefined`) {
          return resolvedField !== null && resolvedField !== void 0 ? resolvedField : [];
        }

        const autoAliasedFieldPropertyName = `${fieldName}__typename_${field === null || field === void 0 ? void 0 : (_field$type = field.type) === null || _field$type === void 0 ? void 0 : _field$type.name}`;
        const aliasedField = source[autoAliasedFieldPropertyName];
        return aliasedField !== null && aliasedField !== void 0 ? aliasedField : [];
      }
    };
  }
}, {
  // lists of non null builtin types
  test: field => {
    var _field$type$ofType$na, _field$type$ofType3, _field$type$ofType3$o;

    return field.type.kind === `LIST` && field.type.ofType.kind === `NON_NULL` && ((_field$type$ofType$na = field.type.ofType.name) !== null && _field$type$ofType$na !== void 0 ? _field$type$ofType$na : (_field$type$ofType3 = field.type.ofType) === null || _field$type$ofType3 === void 0 ? void 0 : (_field$type$ofType3$o = _field$type$ofType3.ofType) === null || _field$type$ofType3$o === void 0 ? void 0 : _field$type$ofType3$o.name) && (0, _helpers.typeIsABuiltInScalar)(field.type);
  },
  transform: ({
    field
  }) => `[${(0, _helpers.findTypeName)(field.type)}!]`
}, {
  // lists of non null types
  test: field => {
    var _field$type$ofType$na2, _field$type$ofType4, _field$type$ofType4$o;

    return field.type.kind === `LIST` && field.type.ofType.kind === `NON_NULL` && ((_field$type$ofType$na2 = field.type.ofType.name) !== null && _field$type$ofType$na2 !== void 0 ? _field$type$ofType$na2 : (_field$type$ofType4 = field.type.ofType) === null || _field$type$ofType4 === void 0 ? void 0 : (_field$type$ofType4$o = _field$type$ofType4.ofType) === null || _field$type$ofType4$o === void 0 ? void 0 : _field$type$ofType4$o.name);
  },
  transform: ({
    field
  }) => `[${(0, _helpers.buildTypeName)((0, _helpers.findTypeName)(field.type))}!]`
}, {
  // scalars
  test: field => field.type.kind === `SCALAR`,
  transform: ({
    field
  }) => {
    if ((0, _helpers.typeIsABuiltInScalar)(field.type)) {
      return field.type.name;
    } else {
      // custom scalars are typed as JSON
      // @todo if frequently requested,
      // make this hookable so a plugin could register a custom scalar
      return `JSON`;
    }
  }
}, {
  // Gatsby node Objects
  test: field => {
    const gatsbyNodeTypes = (0, _fetchNodes.getGatsbyNodeTypeNames)();
    return gatsbyNodeTypes.includes(field.type.name) && field.type.kind === `OBJECT`;
  },
  transform: _transformObject.transformGatsbyNodeObject
}, {
  // lists of gatsby-node objects
  test: field => {
    const gatsbyNodeTypes = (0, _fetchNodes.getGatsbyNodeTypeNames)();
    return field.type.kind === `LIST` && field.type.ofType.kind === `OBJECT` && gatsbyNodeTypes.includes(field.type.ofType.name);
  },
  transform: _transformObject.transformListOfGatsbyNodes
}, {
  // non-gatsby-node objects
  test: field => field.type.kind === `OBJECT`,
  transform: ({
    field
  }) => (0, _helpers.buildTypeName)(field.type.name)
}, {
  // lists of non-gatsby-node objects
  test: field => field.type.kind === `LIST` && field.type.ofType.kind === `OBJECT`,
  transform: ({
    field
  }) => `[${(0, _helpers.buildTypeName)(field.type.ofType.name)}]`
}, {
  // lists of unions
  test: field => field.type.kind === `LIST` && field.type.ofType.kind === `UNION`,
  transform: _transformUnion.transformListOfUnions
}, {
  // list of scalars
  test: field => field.type.kind === `LIST` && field.type.ofType.kind === `SCALAR`,
  transform: ({
    field
  }) => {
    if ((0, _helpers.typeIsABuiltInScalar)(field.type)) {
      return `[${field.type.ofType.name}]`;
    } else {
      return `[JSON]`;
    }
  }
}, {
  // lists of interfaces
  test: field => field.type.kind === `LIST` && field.type.ofType.kind === `INTERFACE`,
  transform: ({
    field
  }) => `[${(0, _helpers.buildTypeName)(field.type.ofType.name)}]`
}, {
  // unions
  test: field => field.type.kind === `UNION`,
  transform: _transformUnion.transformUnion
}, {
  // interfaces
  test: field => field.type.kind === `INTERFACE`,
  transform: ({
    field
  }) => (0, _helpers.buildTypeName)(field.type.name)
}, {
  test: field => (0, _helpers.findTypeKind)(field.type) !== `LIST` && field.type.kind === `NON_NULL`,
  transform: ({
    field
  }) => `${(0, _helpers.buildTypeName)((0, _helpers.findTypeName)(field.type))}!`
} // for finding unhandled types
// {
//   test: () => true,
//   transform: ({ field }) => dd(field),
// },
];
exports.fieldTransformers = fieldTransformers;