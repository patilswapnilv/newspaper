"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.paginatedWpNodeFetch = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _fetchGraphql = _interopRequireDefault(require("../../../utils/fetch-graphql"));

var _store = _interopRequireDefault(require("../../../store"));

/**
 * paginatedWpNodeFetch
 *
 * recursively fetches/paginates remote nodes
 */
const paginatedWpNodeFetch = async (_ref) => {
  let {
    contentTypePlural,
    query,
    nodeTypeName,
    activity,
    helpers,
    throwFetchErrors = false,
    allContentNodes = [],
    after = null,
    settings = {}
  } = _ref,
      variables = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["contentTypePlural", "query", "nodeTypeName", "activity", "helpers", "throwFetchErrors", "allContentNodes", "after", "settings"]);

  if (!settings.limit && typeof settings.limit === `number` && settings.limit === 0) {
    // if the Type.limit plugin option is set to the number 0,
    // we shouldn't fetch anything
    return [];
  }

  if (settings.limit && // if we're about to fetch more than our limit
  allContentNodes.length + variables.first > settings.limit) {
    // just fetch whatever number is remaining
    variables.first = settings.limit - allContentNodes.length;
  } // if the GQL var "first" is greater than our Type.limit plugin option,
  // that's no good


  if (settings.limit && settings.limit < variables.first) {
    // so just fetch our limit
    variables.first = settings.limit;
  }

  const typeCount = _store.default.getState().logger.typeCount[nodeTypeName] || 0;
  const response = await (0, _fetchGraphql.default)({
    query,
    throwFetchErrors,
    variables: Object.assign(Object.assign({}, variables), {}, {
      after
    }),
    errorContext: `Error occured while fetching nodes of the "${nodeTypeName}" type.`
  });
  const {
    data
  } = response;

  if (!data[contentTypePlural] || !data[contentTypePlural].nodes) {
    return allContentNodes;
  }

  let {
    [contentTypePlural]: {
      nodes,
      pageInfo: {
        hasNextPage,
        endCursor
      } = {}
    }
  } = data; // Sometimes private posts return as null.
  // That causes problems for us so let's strip them out

  nodes = nodes.filter(Boolean);

  if (nodes && nodes.length) {
    nodes.forEach(async node => {
      const normalizedNodeTypeName = node.__typename || nodeTypeName;
      node.type = normalizedNodeTypeName; // this is used to filter node interfaces by content types

      node.nodeType = normalizedNodeTypeName;
      allContentNodes.push(node);
    });
    const updatedTypeCount = typeCount + nodes.length;

    if (activity) {
      activity.setStatus(`fetched ${updatedTypeCount}`);
    }

    _store.default.dispatch.logger.incrementTypeBy({
      count: nodes.length,
      type: nodeTypeName
    });
  }

  if (hasNextPage && (!settings.limit || settings.limit > allContentNodes.length)) {
    return paginatedWpNodeFetch(Object.assign(Object.assign({}, variables), {}, {
      contentTypePlural,
      nodeTypeName,
      query,
      allContentNodes,
      activity,
      helpers,
      settings,
      after: endCursor
    }));
  } else {
    return allContentNodes;
  }
};

exports.paginatedWpNodeFetch = paginatedWpNodeFetch;