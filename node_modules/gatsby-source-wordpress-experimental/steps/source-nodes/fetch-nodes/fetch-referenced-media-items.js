"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = fetchReferencedMediaItemsAndCreateNodes;

var _chunk = _interopRequireDefault(require("lodash/chunk"));

var _store = _interopRequireDefault(require("../../../store"));

var _atob = _interopRequireDefault(require("atob"));

var _pQueue = _interopRequireDefault(require("p-queue"));

var _createRemoteMediaItemNode = require("../create-nodes/create-remote-media-item-node");

var _formatLogMessage = require("../../../utils/format-log-message");

var _fetchNodesPaginated = require("./fetch-nodes-paginated");

var _helpers = require("../../create-schema-customization/helpers");

var _process$env$GATSBY_C;

const nodeFetchConcurrency = 2;
const mediaFileFetchQueue = new _pQueue.default({
  concurrency: Number((_process$env$GATSBY_C = process.env.GATSBY_CONCURRENT_DOWNLOAD) !== null && _process$env$GATSBY_C !== void 0 ? _process$env$GATSBY_C : 200) - nodeFetchConcurrency,
  carryoverConcurrencyCount: true
});
const mediaNodeFetchQueue = new _pQueue.default({
  concurrency: nodeFetchConcurrency,
  carryoverConcurrencyCount: true
});
const previouslyRetriedPromises = {};

const pushPromiseOntoRetryQueue = ({
  node,
  helpers,
  createContentDigest,
  actions,
  queue,
  retryKey,
  retryPromise
}) => {
  queue.add(async () => {
    const timesRetried = previouslyRetriedPromises[retryKey] || 0;

    if (timesRetried >= 2) {
      // if we've retried this more than once, pause for a sec.
      await new Promise(resolve => setTimeout(() => resolve(), timesRetried * 500));
    }

    try {
      await retryPromise({
        createContentDigest,
        actions,
        helpers,
        node,
        queue,
        retryKey,
        retryPromise,
        timesRetried
      });
    } catch (error) {
      // Errors that should exit are handled one level down
      // in createRemoteMediaItemNode
      //
      // if we haven't reqeued this before,
      // add it to the end of the queue to
      // try once more later
      if (timesRetried < 5) {
        if (timesRetried > 1) {
          helpers.reporter.info(`pushing ${retryKey} to the end of the request queue.`);
          helpers.reporter.info(`Previously retried ${timesRetried} times already.`);
        }

        previouslyRetriedPromises[retryKey] = timesRetried + 1;
        pushPromiseOntoRetryQueue({
          node,
          helpers,
          createContentDigest,
          actions,
          queue,
          retryKey,
          retryPromise
        });
      } else {
        helpers.reporter.info(`\n\nalready re-queued ${retryKey} 5 times :( sorry.\nTry lowering process.env.GATSBY_CONCURRENT_DOWNLOAD.\nIt's currently set to ${process.env.GATSBY_CONCURRENT_DOWNLOAD}\n\n`); // we already tried this earlier in the queue
        // no choice but to give up :(

        helpers.reporter.panic(error);
      }
    }
  });
};

async function fetchReferencedMediaItemsAndCreateNodes({
  referencedMediaItemNodeIds
}) {
  const state = _store.default.getState();

  const queryInfo = state.remoteSchema.nodeQueries.mediaItems;
  const {
    helpers,
    pluginOptions
  } = state.gatsbyApi;
  const {
    createContentDigest,
    actions
  } = helpers;
  const {
    reporter
  } = helpers;
  const {
    url,
    verbose
  } = pluginOptions;
  const {
    typeInfo,
    settings,
    selectionSet
  } = queryInfo;

  if (settings.limit && settings.limit < referencedMediaItemNodeIds.length) {
    referencedMediaItemNodeIds = referencedMediaItemNodeIds.slice(0, settings.limit);
  }

  const nodesPerFetch = 100;
  const chunkedIds = (0, _chunk.default)(referencedMediaItemNodeIds, nodesPerFetch);
  const activity = reporter.activityTimer((0, _formatLogMessage.formatLogMessage)(typeInfo.nodesTypeName));

  if (verbose) {
    activity.start();
  }

  let allMediaItemNodes = [];

  for (const [index, relayIds] of chunkedIds.entries()) {
    pushPromiseOntoRetryQueue({
      helpers,
      createContentDigest,
      actions,
      queue: mediaNodeFetchQueue,
      retryKey: `Media Item query #${index}`,
      retryPromise: async () => {
        // relay id's are base64 encoded from strings like attachment:89381
        // where 89381 is the id we want for our query
        // so we split on the : and get the last item in the array, which is the id
        // once we can get a list of media items by relay id's, we can remove atob
        const ids = relayIds.map(id => (0, _atob.default)(id).split(`:`).slice(-1)[0]);
        const query = `
          query MEDIA_ITEMS($in: [ID]) {
            mediaItems(first: ${nodesPerFetch}, where:{ in: $in }) {
              nodes {
                ${selectionSet}
              }
            }
          }
        `;
        const allNodesOfContentType = await (0, _fetchNodesPaginated.paginatedWpNodeFetch)({
          first: nodesPerFetch,
          contentTypePlural: typeInfo.pluralName,
          nodeTypeName: typeInfo.nodesTypeName,
          query,
          url,
          helpers,
          settings,
          in: ids,
          // this allows us to retry-on-end-of-queue
          throwFetchErrors: true
        });
        allNodesOfContentType.forEach(node => {
          allMediaItemNodes.push(node);
          pushPromiseOntoRetryQueue({
            node,
            helpers,
            createContentDigest,
            actions,
            queue: mediaFileFetchQueue,
            retryKey: node.mediaItemUrl,
            retryPromise: async ({
              createContentDigest,
              actions,
              helpers,
              node,
              retryKey,
              timesRetried
            }) => {
              let localFileNode = await (0, _createRemoteMediaItemNode.createRemoteMediaItemNode)({
                mediaItemNode: node,
                fixedBarTotal: referencedMediaItemNodeIds.length,
                helpers
              });

              if (timesRetried > 1) {
                helpers.reporter.info(`Successfully fetched ${retryKey} after retrying ${timesRetried} times`);
              }

              if (!localFileNode) {
                return;
              }

              node = Object.assign(Object.assign({}, node), {}, {
                remoteFile: {
                  id: localFileNode.id
                },
                localFile: {
                  id: localFileNode.id
                },
                parent: null,
                internal: {
                  contentDigest: createContentDigest(node),
                  type: (0, _helpers.buildTypeName)(`MediaItem`)
                }
              });
              await actions.createNode(node);
            }
          });
        });
        activity.setStatus(`fetched ${allMediaItemNodes.length}`);
      }
    });
  }

  await mediaNodeFetchQueue.onIdle();
  await mediaFileFetchQueue.onIdle();

  if (!allMediaItemNodes || !allMediaItemNodes.length) {
    return;
  }

  if (verbose) {
    activity.end();
  }
}